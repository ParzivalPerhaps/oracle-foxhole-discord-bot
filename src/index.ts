const mongoose = require('mongoose');
require('dotenv').config();

const { setTimeout } = require('timers/promises');
import { Client, IntentsBitField, EmbedBuilder, PermissionsBitField, ActivityType, Channel, Message, Interaction, User, GuildMemberRoleManager, ChannelType, PermissionOverwrites } from "discord.js";
import OGuildData from "./models/OGuildData";
import { registerCommands } from "./commands";
import { Types } from "mongoose";
import Ticket from "./models/Ticket";
const token = process.env.TOKEN;

const version = "0.1.11";

mongoose.connect(process.env.MONGO_CONNECTION_URI).then(() => {

async function checkGuild(context: Interaction | Message) {
    let oData = await OGuildData.findOne({ guildId: context.guildId });

    if (!oData && context.guildId){
        await registerCommands(context.guildId);
        let currentWarNumber: number = 0;

        try {
            let wr = (await (await fetch('https://war-service-live.foxholeservices.com/api/worldconquest/war')).json()).warNumber;

            currentWarNumber = wr;
        } catch (error) {
            
        }

        oData = await OGuildData.create({
            guildId : context.guildId,
            managementRoles : [],
            newUserTicketChannel : "-1",
            currentWar : currentWarNumber,
            tickets: [],
            lastUsedVersion: version
        })
    } else if (oData && context.guildId && oData.lastUsedVersion != version){
        await registerCommands(context.guildId);

        await oData.updateOne({
            lastUsedVersion: version
        })
    }
}

let createTicket = async (type: "logistics" | "recruit", users: User[], interaction: Interaction) => {
    await checkGuild(interaction);

    let oData = await OGuildData.findOne({ guildId: interaction.guildId });

    if (!oData) return;

    if (type == 'logistics'){
        if (oData.logisticsTicketChannel){
            
        }
    }else if (type == 'recruit'){

    }
}

let isolateChannelId = (messageId: string) => {
    return messageId.split('/')[5];
};

let isolateMessageId = (messageId: string) => {
    return messageId.split('/')[6];
};

let createRole = async (name: string, color: string, context: any) => {
    context.guild.roles.create({name: name, color: color});
};

let createOracleEmbed = (header: string, text: string, fields: any[], link: string) => {
    const voidEmbed = new EmbedBuilder()
                .setColor('#1c3627')
                .setTitle(header)
                .setAuthor({ name: 'Oracle Foxhole Bot'})
                .setDescription(text)
                .setThumbnail('https://i.imghippo.com/files/GvV6040sj.png')
                .setTimestamp()
                .setFooter({ text: 'Message generated by Oracle Bot, forward any concerns to: parzival63', iconURL: 'https://i.imghippo.com/files/GvV6040sj.png' });
                
                if (fields){
                    for (let i = 0; i < fields.length; i++) {
                        voidEmbed.addFields({name: fields[i].name, value: fields[i].value});
                    }
                }

                if (link){
                    voidEmbed.setURL(link);
                }
                

    return voidEmbed;
};

const c = new Client({
    intents: [
        IntentsBitField.Flags.Guilds, 
        IntentsBitField.Flags.GuildMessages, 
        IntentsBitField.Flags.GuildMembers, 
        IntentsBitField.Flags.GuildModeration,
        IntentsBitField.Flags.MessageContent,
        IntentsBitField.Flags.GuildMessageReactions,
        IntentsBitField.Flags.GuildMessageTyping,
        IntentsBitField.Flags.DirectMessages]
});

if (!c) {
    console.error("Failed to start ORACLE client");
    return;
}

c.on('ready', async () => {
    if (!c.user) return;

    console.log('Oracle FX Started...');

    let currentWarNumber: number = 0;

    try {
        let wr = (await (await fetch('https://war-service-live.foxholeservices.com/api/worldconquest/war')).json()).warNumber;

        currentWarNumber = wr;
    } catch (error) {
        
    }

    c.user.setPresence({ 
        activities: [{ 
            name: currentWarNumber != 0 ? `War ${currentWarNumber}` : 'The Good Fight', 
            type: ActivityType.Competing, 
        }], 
        status: 'online' 
    });
});

c.on('messageCreate', async (msg: Message) => {
    if (msg.author.bot || !msg.guildId) return;

    
    checkGuild(msg);
    
    const q = await Ticket.findOne({
        channelId: msg.channelId
    })

    if (q){
        await q.updateOne({
            $push: {transcript: msg.author.username + " (" + msg.createdAt.toTimeString() + "): " + msg.content}
        })
    }
});

c.on('interactionCreate', async (interaction: Interaction) => {
    if (!(interaction.isChatInputCommand() || interaction.isButton()) || !interaction.guildId) return;

    await checkGuild(interaction);
    let oData = await OGuildData.findOne({ guildId: interaction.guildId });

    if (interaction.isButton()){
        if (interaction.customId.startsWith('join_logi_ticket_')){
            let ticketId = interaction.customId.substring(interaction.customId.length - 4, interaction.customId.length);

            const tckt = await Ticket.findOne({
                ticketId: ticketId
            });

            if (!tckt){
                interaction.reply({content: '*Error: Invalid Ticket ID*', ephemeral: true});
                return;
            }

            if (!interaction.member) return;

            (interaction.member.roles as GuildMemberRoleManager).add(tckt.ticketRoleId);

            const rplyEmbed = createOracleEmbed("Logistics Ticket Joined [" + tckt.ticketId + "]", "You have joined " + (tckt.author) + "'s logistics ticket at " + tckt.location + "\n\nRun the */deliver* command in <#" + tckt.channelId + "> to mark your contributions and use the channel to communicate with fellow soldiers.", tckt.logisticsTypes?.map((v, i) => {
                
                if (!tckt.demanded) return {name: "A", value: "A"};
                return {name: v.toString(), value: tckt.demanded[i].toString()}
            }) as {value: string, name: string}[], "");

            interaction.reply({embeds: [rplyEmbed], ephemeral: true});
        }else if (interaction.customId == 'enlist_btn' && oData){
            const activeRole = oData.activeRole;
            const inactiveRole = oData.inactiveRole;

            if (!activeRole) {
                interaction.reply({content: '*Error: Active Role has not been configured*', ephemeral: true});
                return;
            }

            if (!inactiveRole) {
                interaction.reply({content: '*Error: Inactive Role has not been configured*', ephemeral: true});
                return;
            }

            if (!interaction.member) return;

            if ((interaction.member.roles as GuildMemberRoleManager).cache.some((v) => {return v.id == activeRole})){
                interaction.reply({content: `*You've already enlisted! Get out there and fight*`, ephemeral: true});
                return;
            }else{
                (interaction.member.roles as GuildMemberRoleManager).add(activeRole);
                interaction.reply({content: '*Successfully signed up for war ' + (oData.currentWar) +' *', ephemeral: true});
                return;
            }
        }else if (interaction.customId.startsWith("cancel_logi_ticket_") && oData){
            const t = await Ticket.findOne({
                author: interaction.user.username,
                ticketId: interaction.customId.substring(interaction.customId.length - 4, interaction.customId.length),
                complete: false
            })

            if (!t){
                interaction.reply({content: "*No logistics request started, run **/create-logistics-ticket** to start builder*", ephemeral: true})
                return
            }

            await t.deleteOne();
            interaction.reply({content: "*Current builder discarded, start a new ticket by running the **/create-logistics-ticket** command*", ephemeral: true})
        }
    }
    

    if (!oData || !interaction.member || interaction.isButton()) return;
        
    try {

        if (interaction.commandName == 'start-new-war'){
            if ((interaction.member.permissions as Readonly<PermissionsBitField>).has((PermissionsBitField as any).ManageMessages)){
                if (!interaction.guild) return;

                const activeRole = oData.activeRole;
                const inactiveRole = oData.inactiveRole;

                const users = await interaction.guild.members.list();

                let membersOfCurrentWar = 0;

                for (let i = 0; i < users.size; i++) {
                   if (users.at(i)?.roles.cache.some((v) => {return v.id == activeRole})) membersOfCurrentWar += 1;
                }

                const voidEmbed = createOracleEmbed('New War!', `War ` + oData.currentWar + " has ended, please run **/enlist** to be reactivated for **War " + (interaction.options.getInteger("war-number")) + "**.", 
                [{name: `War ${oData.currentWar} Participants`, value: membersOfCurrentWar.toString()}], "");

                await oData.updateOne({currentWar: interaction.options.getInteger("war-number")});

                

                if (!activeRole) {
                    interaction.reply({content: '*Error: Active Role has not been defined, run /set-active-role [role] to change the active role*', ephemeral: true});
                    return;
                }

                if (!inactiveRole) {
                    interaction.reply({content: '*Error: Inactive Role has not been defined, run /set-inactive-role [role] to change the inactive role*', ephemeral: true});
                    return;
                }

                for (let i = 0; i < users.size; i++) {
                    users.at(i)?.roles.remove(activeRole);
                    users.at(i)?.roles.add(inactiveRole);
                }
                

                interaction.client.channels.fetch(interaction.options.getChannel("notification-channel")?.id || interaction.channelId).then((channel) => {
                    if (!channel) return;
                    (channel as any).send({embeds: [voidEmbed], components: [
                        {
                            type: 2,
                            style: 1,
                            label: "Enlist!",
                            custom_id: "enlist_btn"
                        }
                    ]});
                });        

                interaction.reply({content: '*New War Started*', ephemeral: true});
            }else{
                interaction.reply({content: '*Insufficient Permissions*', ephemeral: true});
            }
        }else if (interaction.commandName == 'set-active-role'){
            if ((interaction.member.permissions as Readonly<PermissionsBitField>).has((PermissionsBitField as any).ManageMessages)){
                const rl = interaction.options.getRole("role");
                
                if (!rl){
                    interaction.reply({content: '*Invalid role provided, please try again*', ephemeral: true});
                    return;
                }

                await oData.updateOne({
                    activeRole: rl.id
                })

                interaction.reply({content: '*Active Role Set*', ephemeral: true});
            }else{
                interaction.reply({content: '*Insufficient Permissions*', ephemeral: true});
            }
        }else if (interaction.commandName == 'set-inactive-role'){
            if ((interaction.member.permissions as Readonly<PermissionsBitField>).has((PermissionsBitField as any).ManageMessages)){
                const rl = interaction.options.getRole("role");
                
                if (!rl){
                    interaction.reply({content: '*Invalid role provided, please try again*', ephemeral: true});
                    return;
                }

                await oData.updateOne({
                    inactiveRole: rl.id
                })

                interaction.reply({content: '*Inactive Role Set*', ephemeral: true});
            }else{
                interaction.reply({content: '*Insufficient Permissions*', ephemeral: true});
            }
        }else if (interaction.commandName == 'enlist'){
            const activeRole = oData.activeRole;
            const inactiveRole = oData.inactiveRole;

            if (!activeRole) {
                interaction.reply({content: '*Error: Active Role has not been configured*', ephemeral: true});
                return;
            }

            if (!inactiveRole) {
                interaction.reply({content: '*Error: Inactive Role has not been configured*', ephemeral: true});
                return;
            }

            

            if ((interaction.member.roles as GuildMemberRoleManager).cache.some((v) => {return v.id == activeRole})){
                interaction.reply({content: `*You've already enlisted! Get out there and fight*`, ephemeral: true});
                return;
            }else{
                (interaction.member.roles as GuildMemberRoleManager).add(activeRole);
                interaction.reply({content: '*Successfully signed up for war ' + (oData.currentWar) +' *', ephemeral: true});
                return;
            }

        }else if (interaction.commandName == 'create-logistics-ticket'){
            const activeRole = oData.activeRole;
            const inactiveRole = oData.inactiveRole;

            if (!activeRole) {
                interaction.reply({content: '*Error: Active Role has not been configured*', ephemeral: true});
                return;
            }

            if (!inactiveRole) {
                interaction.reply({content: '*Error: Inactive Role has not been configured*', ephemeral: true});
                return;
            }

            

            if ((interaction.member.roles as GuildMemberRoleManager).cache.some((v) => {return v.id == activeRole})){
                interaction.reply({content: `*You must be enlisted to start a logistics ticket, enlist by running the **/enlist command***`, ephemeral: true});
                return;
            }

            if (!interaction.guild) return;

            let cat = interaction.client.channels.cache.find((v) => {return v.type == ChannelType.GuildCategory && v.name == "Oracle Logi Tickets"});

            if (!cat){
                cat = await interaction.guild.channels.create({
                    name: "Oracle Logi Tickets",
                    type: ChannelType.GuildCategory,
                    // your permission overwrites or other options here
                });
            }

            let ticketId = Math.random().toString(36).slice(2, 6);

            while ((await Ticket.findOne({ticketId: ticketId}))){
                ticketId = Math.random().toString(36).slice(2, 6);
            }

            const rl = await interaction.guild.roles.create({
                name: "logi-support-" + ticketId
            });

            const chnl = await interaction.guild.channels.create({
                name: "logi-ticket-" + ticketId,
                type: ChannelType.GuildText,
                parent: cat.id,
                permissionOverwrites: [
                    {
                        id: interaction.guild.roles.everyone.id, 
                        deny: ["ViewChannel"]
                    },
                    {
                        id: rl.id, 
                        allow: ["ViewChannel"]
                    },
                    {
                        id: interaction.guild.roles.highest.id,
                        allow: ["ViewChannel"]
                    },
                ]
                // your permission overwrites or other options here
            });

            const ticketEmbed = createOracleEmbed('Logistics Ticket ' + (interaction.options.getString('logi-type')) +' (' + interaction.options.getString('sub-type') + ') - ' + interaction.options.getString('location'), " ", 
            [], "");
            
            const msg = await chnl.send({embeds: [ticketEmbed]});

            const tckt = await Ticket.create({
                channelId: chnl.id,
                ticketRoleId: rl.id,
                data: [],
                guildId: interaction.guildId,
                ticketId: ticketId,
                author: interaction.user.username,
                delivered: [],
                location: interaction.options.getString('location'),
                transcript: [],
                notes: interaction.options.getString('notes'),
                complete: false,
                updateEmbed: msg.id
            });

            await oData.updateOne({
                $push: {tickets: tckt.id}
            });

            


            


            interaction.client.channels.fetch(oData.logisticsTicketChannel || interaction.channelId).then(async (channel) => {
                if (!channel) return;
                /*
                await (channel as any).send({embeds: [ticketEmbed], components: [
                    {
                        type: 1,
                        components: [
                            {
                                type: 2,
                                style: 1,
                                label: "Join Ticket",
                                custom_id: "join_logi_ticket_" + ticketId
                            }
                        ]
                    }
                ],});
                */


                const logiChannelEmbed = createOracleEmbed('Logistics Ticket (' + tckt.location + ")" , "To remove resources from the ticket run lb-remove\n\nIf you're done adding resource requirements, run lb-complete.", 
                    tckt.logisticsTypes?.map((v, i) => {
                    if (!tckt || !tckt.demanded) return {name: "A", value: "A"};
                    return {name: v.toString(), value: tckt.demanded[i].toString()}
                }) as {value: string, name: string}[] , "");

                interaction.reply({embeds: [logiChannelEmbed], components: [
                    {
                        type: 1,
                        components: [
                            {
                                type: 2,
                                style: 2,
                                label: "Cancel Logi Request Builder",
                                custom_id: "cancel_logi_ticket_" + tckt.ticketId
                            }
                        ]
                    }
                ], ephemeral: true});
            });  


            
        }else if (interaction.commandName == 'lb-add'){
            let t = await Ticket.findOne({
                author: interaction.user.username,
                complete: false
            })

            if (!t || !t.logisticsTypes || !interaction.options.getString("resource")){
                interaction.reply({content: "*No logistics request started, run **/create-logistics-ticket** to start builder*", ephemeral: true})
                return
            }

            if (t.logisticsTypes.find((v) => {
                return (interaction.options.getString("resource") as string).toLowerCase() == v.toLowerCase()
            })){
                let w = t.demanded;

                if (!w) return;

                w[t.logisticsTypes.findIndex((v) => {
                    return (interaction.options.getString("resource") as string).toLowerCase() == v.toLowerCase()
                })] += interaction.options.getInteger("amount") || 0;

                await t.updateOne({
                    demanded: w
                })
            }else{
                await t.updateOne({
                    $push: {logisticsTypes : interaction.options.getString("resource"), demanded : interaction.options.getInteger("amount"), delivered : 0},
                })
            }
            
            t = await Ticket.findOne({
                author: interaction.user.username,
                complete: false
            })

            if (!t) return;

            const logiChannelEmbed = createOracleEmbed('Logistics Ticket (' + t.location + ")" , "To remove resources from the ticket run lb-remove\n\nIf you're done adding resource requirements, run lb-complete.", 
                t.logisticsTypes?.map((v, i) => {
                   
                    if (!t || !t.demanded) return {name: "A", value: "A"};
                    return {name: v.toString(), value: t.demanded[i].toString()}
                }) as {value: string, name: string}[] , "");

                interaction.reply({embeds: [logiChannelEmbed], components: [
                    {
                        type: 1,
                        components: [
                            {
                                type: 2,
                                style: 2,
                                label: "Cancel Logi Request Builder",
                                custom_id: "cancel_logi_ticket_" + t.ticketId
                            }
                        ]
                    }
                ], ephemeral: true});
        }else if (interaction.commandName == 'lb-remove'){
            let t = await Ticket.findOne({
                author: interaction.user.username,
                complete: false
            })

            if (!t || !t.logisticsTypes || !interaction.options.getString("resource")){
                interaction.reply({content: "*No logistics request started, run **/create-logistics-ticket** to start builder*", ephemeral: true})
                return
            }

            if (t.logisticsTypes.find((v) => {
                return (interaction.options.getString("resource") as string).toLowerCase() == v.toLowerCase();
            })){
                let w = t.demanded;

                if (!w) return;

                const o = t.logisticsTypes.findIndex((v) => {
                    return (interaction.options.getString("resource") as string).toLowerCase() == v.toLowerCase();
                });

                if (interaction.options.getInteger("amount")){
                    w[o] -= interaction.options.getInteger("amount") || 0;

                    w[o] = Math.max(0, w[t.logisticsTypes.findIndex((v) => {
                        return (interaction.options.getString("resource") as string).toLowerCase() == v.toLowerCase();
                    })]);
                }else{
                    w[o] = 0;
                }

                if (w[o] == 0){
                    let m = t.logisticsTypes;
                    let r = t.delivered;

                    w = w.filter((v, i) => {
                        return i != o;
                    })

                    m = m.filter((v, i) => {
                        return i != o;
                    })

                    if (r){
                        r = r.filter((v, i) => {
                            return i != o;
                        })
                    }
                    
                    await t.updateOne({
                        logisticsTypes: m,
                        delivered: r
                    })
                }

                await t.updateOne({
                    demanded: w
                });

                t = await Ticket.findOne({
                    author: interaction.user.username,
                    complete: false
                })

                if (!t) return;

                const logiChannelEmbed = createOracleEmbed('Logistics Ticket (' + t.location + ")" , "To remove resources from the ticket run lb-remove\n\nIf you're done adding resource requirements, run lb-complete.", 
                t.logisticsTypes?.map((v, i) => {
                    if (!t || !t.demanded) return {name: "A", value: "A"};
                    return {name: v.toString(), value: t.demanded[i].toString()}
                }) as {value: string, name: string}[] , "");

                interaction.reply({embeds: [logiChannelEmbed], components: [
                    {
                        type: 1,
                        components: [
                            {
                                type: 2,
                                style: 2,
                                label: "Cancel Logi Request Builder",
                                custom_id: "cancel_logi_ticket_" + t.ticketId
                            }
                        ]
                    }
                ], ephemeral: true});

            }else{
                interaction.reply({content: "*Resource not found within ticket, did you spell it correctly?*", ephemeral: true});
                return;
            }
            
        }else if (interaction.commandName == 'lb-view'){
            const t = await Ticket.findOne({
                author: interaction.user.username,
                complete: false
            })

            if (!t){
                interaction.reply({content: "*No logistics request started, run **/create-logistics-ticket** to start builder*", ephemeral: true})
                return
            }

            const logiChannelEmbed = createOracleEmbed('Logistics Ticket (' + t.location + ")" , "To remove resources from the ticket run lb-remove\n\nIf you're done adding resource requirements, run lb-complete.", 
                t.logisticsTypes?.map((v, i) => {
                    console.log(v, i);
                    
                    if (!t.demanded) return {name: "A", value: "A"};
                    return {name: v.toString(), value: t.demanded[i].toString()}
                }) as {value: string, name: string}[] , "");

                interaction.reply({embeds: [logiChannelEmbed], components: [
                    {
                        type: 1,
                        components: [
                            {
                                type: 2,
                                style: 2,
                                label: "Cancel Logi Request Builder",
                                custom_id: "cancel_logi_ticket_" + t.ticketId
                            }
                        ]
                    }
                ], ephemeral: true});
        }else if (interaction.commandName == 'lb-complete'){
            const t = await Ticket.findOne({
                author: interaction.user.username,
                complete: false
            })

            if (!t){
                interaction.reply({content: "*No logistics request started, run **/create-logistics-ticket** to start builder*", ephemeral: true})
                return
            }

            await (interaction.member.roles as GuildMemberRoleManager).add(t.ticketRoleId);

            const p = await c.channels.fetch(t.channelId)
            if (!p || !p.isTextBased()) {
                
                return
            }

            const logiChannelEmbed = createOracleEmbed('Logistics Ticket (' + t.location + ")" , "To remove resources from the ticket run lb-remove\n\nIf you're done adding resource requirements, run lb-complete.", 
                t.logisticsTypes?.map((v, i) => {
                    console.log(v, i);
                    
                    if (!t.demanded) return {name: "A", value: "A"};
                    return {name: v.toString(), value: t.demanded[i].toString()}
                }) as {value: string, name: string}[] , "");

                const ticketChannelEmbed = createOracleEmbed('Logistics Ticket (' + t.location + ")" , "Welcome to support ticket " + t.ticketId + ", help out by delivering the requested supplies and then running the **/deliver** command to report your work\n\nThe fields below are automatically updated as deliveries are reported\n\nThis channel will automatically lock when all requirements are fulfilled", 
                t.logisticsTypes?.map((v, i) => {
                    if (!t.demanded || !t.delivered) return {name: "A", value: "A"};
                    return {name: v.toString(), value: t.delivered[i].toString() + " / " + t.demanded[i].toString()}
                }) as {value: string, name: string}[] , "");

            
            await p.messages.fetch(t.updateEmbed).then(msg => (msg as any).edit({embeds: [ticketChannelEmbed]}))

            await t.updateOne({
                complete: true
            })
            

            interaction.client.channels.fetch(oData.logisticsTicketChannel || interaction.channelId).then(async (channel) => {
                if (!channel) return;

                (channel as any).send({embeds: [logiChannelEmbed], components: [
                    {
                        type: 1,
                        components: [
                            {
                                type: 2,
                                style: 2,
                                label: "Join Ticket",
                                custom_id: "join_logi_ticket_" + t.ticketId
                            }
                        ]
                    }
                ]})
            })



        }else if (interaction.commandName == 'lb-discard'){
            const t = await Ticket.findOne({
                author: interaction.user.username,
                complete: false
            })

            if (!t){
                interaction.reply({content: "*No logistics request started, run **/create-logistics-ticket** to start builder*", ephemeral: true})
                return
            }

            await t.deleteOne();
            interaction.reply({content: "*Current builder discarded, start a new ticket by running the **/create-logistics-ticket** command*", ephemeral: true})
        }else if (interaction.commandName == 'deliver'){
            let t = await Ticket.findOne({
                complete: true,
                channelId: interaction.channelId
            })

            if (!t || !t.logisticsTypes){
                interaction.reply({content: "*Invalid channel, make sure the logistics request is complete and the command is being used in a ticket channel*", ephemeral: true})
                return
            }

            const o = t.logisticsTypes.findIndex((v) => {
                return (interaction.options.getString("resource") as string).toLowerCase() == v.toLowerCase();
            });

            if (o == -1) {
                interaction.reply({content: "*Unable to find resource, make sure you spelled it correctly (not case sensitive)*", ephemeral: true})
                return;
            }

            if (!t.delivered) return;

            let y = t.delivered;

            y[o] += interaction.options.getInteger("amount") || 0;

            await t.updateOne({
                delivered: y
            })

            t = await Ticket.findOne({
                complete: true,
                channelId: interaction.channelId
            })

            if (!t) return;

            const ticketChannelEmbed = createOracleEmbed('Logistics Ticket (' + t.location + ")" , "Welcome to support ticket " + t.ticketId + ", help out by delivering the requested supplies and then running the **/deliver** command to report your work\n\nThe fields below are automatically updated as deliveries are reported\n\nThis channel will automatically lock when all requirements are fulfilled", 
                t.logisticsTypes?.map((v, i) => {
                    if (!t || !t.demanded || !t.delivered) return {name: "A", value: "A"};
                    return {name: v.toString(), value: t.delivered[i].toString() + " / " + t.demanded[i].toString()}
                }) as {value: string, name: string}[] , "");

            console.log(t);
            
            if (!interaction.channel) return;

            await interaction.channel.messages.fetch(t.updateEmbed).then(msg => (msg as any).edit({embeds: [ticketChannelEmbed]}));

            interaction.reply({content: "**Logged delivery of " + interaction.options.getInteger("amount") + " " + interaction.options.getString("resource") + (interaction.options.getString("resource")?.endsWith("s") ? "" : "s") + " to " + t.location +" by <@" + (interaction.user.id) + ">**"})
        }


        /*
        if (interaction.commandName == 'void') {
            if ((interaction.member.permissions as Readonly<PermissionsBitField>).has(PermissionsBitField.ManageMessages)){
                const reason = await interaction.options.getString('reason');
            
                const staffName = interaction.user.username;
                let authorName = 'NUL';
                let channelName = 'NUL';

                let msg = 'NUL';

                const ch = await interaction.guild.channels.fetch(isolateChannelId(interaction.options.getString('message')));

                await ch.messages.fetch(isolateMessageId(interaction.options.getString('message'))).then((message) => {
                    console.log("NAME: " + message["author"]["username"]);
                    msg = message;
                    
                    authorName = message["author"]["username"];

                    try{
                        let str = "\n*Hi! Your message has been voided by a staff member. Please review the rules and try again.*";

                        if (reason) {
                            str += " \n **Reason:** " + reason;
                        }

                        message["author"].send(str);
                    } catch (err) {
                        console.log("User has DMs disabled");
                    }
                    
                    message.delete();
                });

                channelName = ch.name;

                console.log(authorName);
                console.log(channelName);
                console.log(staffName); 

                let fields = [{name: 'Voided Message', value: msg['content']}];

                if (reason) {
                    console.log(reason);
                    fields.push({name: 'Reason', value: reason});
                }

                const voidEmbed = createArgoEmbed('Voided Action', `**Staff:** ${staffName}\n**Author:** ${authorName}\n**Channel:** #${channelName}`, fields);

                interaction.client.channels.fetch(configData.logChannelId).then((channel) => {
                    channel.send({embeds: [voidEmbed]});
                });        

                interaction.reply({content: '*Message Voided, User Notified, Log Created*', ephemeral: true});
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
            

        }else if (interaction.commandName == 'refreshfactions') {
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){

                

            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if (interaction.commandName == 'assignfaction') {
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                updateInfo();

                const user = await interaction.options.getUser('user');
                const faction = await interaction.options.getString('faction');

                let role = await interaction.guild.roles.fetch(factions[faction]["role"]);
                console.log(role);

                let removedFaction = "N/A";

                for (let i = 0; i < factionTags.length; i++) {
                    console.log(factionTags[i]);
                    console.log(factions[factionTags[i]]);

                    if (factions[factionTags[i]] == undefined) continue;

                    if (factions[factionTags[i]]["owner"] != user.id) continue;

                    await interaction.guild.members.fetch(user.id).then((member) => {
                        console.log(factions[factionTags[i]]["role"]);
                        member.roles.remove(factions[factionTags[i]]["role"]);
                    });

                    factions[factionTags[i]]["owner"] = "Null";
                    removedFaction = factionTags[i];
                }   

                let authorName = 'NUL';

                await interaction.guild.members.fetch(user.id).then((member) => {
                    member.roles.add(role.id);
                    factions[faction]["owner"] = user.id;
                    authorName = member.displayName;
                });

                const voidEmbed = createArgoEmbed(authorName + " Assigned to " + faction, `**Staff Member:** ` + interaction.user.displayName, [{name: 'Removed Roles', value: removedFaction}]);

                interaction.client.channels.fetch(configData.logChannelId).then((channel) => {
                    channel.send({embeds: [voidEmbed]});
                });  

                interaction.reply({content: '*Faction Assigned* | ' + user.displayName + " to " + faction, ephemeral: true});
                writeConfig();
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if (interaction.commandName == 'removeassignment') {
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                let removedFaction = "N/A";
                for (let i = 0; i < factionTags.length; i++) {
                    if (factions[factionTags[i]]["owner"] != interaction.options.getUser('user').id) continue;

                    await interaction.guild.members.fetch(interaction.options.getUser('user').id).then((member) => {
                        member.roles.remove(factions[factionTags[i]]["role"]);
                    });

                    factions[factionTags[i]]["owner"] = "Null";
                    removedFaction = factionTags[i];
                }

                const voidEmbed = createArgoEmbed(interaction.options.getUser('user').displayName + " Faction Assignment Removed", `**Staff Member:** ` + interaction.user.displayName, [{name: 'Removed Roles', value: removedFaction}]);

                interaction.client.channels.fetch(configData.logChannelId).then((channel) => {
                    channel.send({embeds: [voidEmbed]});
                });

                writeConfig();

                interaction.reply({content: '*Faction Assignment Removed*', ephemeral: true});
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if (interaction.commandName == 'viewall') {
            let str = "";
            for (let i = 0; i < factionTags.length; i++) {
                let faction = factions[factionTags[i]];

                console.log(faction);
                if (faction == undefined) continue;
                if (faction["owner"] == undefined || faction['owner'] == 'Null') continue;

                let user;
                let role;

                await interaction.guild.roles.fetch(faction["role"]).then((r) => {
                    role = r.name;
                });
                console.log(role);
                await interaction.guild.members.fetch(faction["owner"]).then((u) => {
                    user = u.displayName;
                });

                str += "\n\n**Faction:** " + faction["name"] + "\n**Tag:** " + factionTags[i] + "\n**Role:** " + role + "\n**Owner:** " + user;

                
            }

            const voidEmbed = createArgoEmbed("Faction Assignments Overview", str, null, null);

            interaction.channel.send({embeds: [voidEmbed]});
            interaction.reply({content: '*Faction Assignments Overview Processed*', ephemeral: true});
        }else if (interaction.commandName == 'accept'){
            let msg = interaction.options.getString('proposal');
            
            let authorName;
            let channelName;
            let channelF;

            

            await interaction.guild.channels.fetch(isolateChannelId(msg)).then((channel) => {
                channelName = channel.name;
                channelF = channel;
                
                channel.messages.fetch(isolateMessageId(msg)).then((message) => {
                    const voidEmbed = createArgoEmbed('Proposal Accepted', '**Channel:** #' + channelName, [{name: 'Accepted Proposal', value: message.content}], null);
                    message.author.send({embeds: [voidEmbed]})
                });
            });

            await channelF.messages.fetch(isolateMessageId(msg)).then((message) => {authorName = message.author.displayName;});

            const voidEmbed = createArgoEmbed('Proposal Accepted', '**Staff: **' + interaction.user.displayName + '\n**Author:** ' + authorName + '\n**Channel:** #' + channelName, [{name: 'Accepted Proposal', value: msg}]);

            interaction.client.channels.fetch(configData.logChannelId).then((channel) => {
                channel.send({embeds: [voidEmbed]});
            });

            interaction.reply({content: '*Proposal Accepted, User Notified, Log Created*', ephemeral: true});
        }else if (interaction.commandName == 'deny'){
            let msg = interaction.options.getString('proposal');
            
            let authorName;
            let channelName;
            let channelF;

            

            await interaction.guild.channels.fetch(isolateChannelId(msg)).then((channel) => {
                channelName = channel.name;
                channelF = channel;
                
                channel.messages.fetch(isolateMessageId(msg)).then((message) => {
                    const voidEmbed = createArgoEmbed('Proposal Denied', '**Channel:** #' + channelName, [{name: 'Denied Proposal', value: message.content}], null);
                    message.author.send({embeds: [voidEmbed]})
                });
            });

            await channelF.messages.fetch(isolateMessageId(msg)).then((message) => {authorName = message.author.displayName;});

            const voidEmbed = createArgoEmbed('Proposal Denied', '**Staff: **' + interaction.user.displayName + '\n**Author:** ' + authorName + '\n**Channel:** #' + channelName, [{name: 'Denied Proposal', value: msg}]);

            interaction.client.channels.fetch(configData.logChannelId).then((channel) => {
                channel.send({embeds: [voidEmbed]});
            });

            interaction.reply({content: '*Proposal Denied, User Notified, Log Created*', ephemeral: true});
        }else if (interaction.commandName == 'setlogchannel'){
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                const channel = await interaction.options.getChannel('channel');

                logChannelId = channel.id;

                interaction.reply({content: '*Log Channel Set*', ephemeral: true});
                writeConfig();
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if (interaction.commandName == 'addformattedchannel'){
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                const channel = await interaction.options.getChannel('channel');

                formattedChannels.push(channel.name);

                interaction.reply({content: '*Channel Added To List*', ephemeral: true});
                writeConfig();
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if (interaction.commandName == 'removeformattedchannel'){
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                const channel = await interaction.options.getChannel('channel');

                formattedChannels.splice(formattedChannels.indexOf(channel.name), 1);

                interaction.reply({content: '*Channel Removed From List*', ephemeral: true});
                writeConfig();
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if(interaction.commandName == 'viewallformattedchannels'){
            let str = "";
            for (let i = 0; i < formattedChannels.length; i++) {
                str += "\n\n**Channel:** #" + formattedChannels[i];
            }

            const voidEmbed = createArgoEmbed("Formatted Channel List", str, null, null);

            interaction.channel.send({embeds: [voidEmbed]});
            interaction.reply({content: '*Formatted Channel List Processed*', ephemeral: true});
        } else if (interaction.commandName == 'addfaction'){
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                const name = await interaction.options.getString('name');
                const tag = await interaction.options.getString('tag');
                const color = await interaction.options.getString('color');

                factions[tag] = {name: name, color: color, owner: "Null"};

                interaction.reply({content: '*Faction Added*', ephemeral: true});
                factionTags.push(tag);
                factions["list"] = factionTags;
                writeConfig();
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if (interaction.commandName == 'removefaction'){
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                const tag = await interaction.options.getString('tag');

                delete factions[tag];

                interaction.reply({content: '*Faction Removed*', ephemeral: true});
                writeConfig();
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }else if (interaction.commandName == 'listfactions'){
            let str = "";
            for (let i = 0; i < factionTags.length; i++) {
                let faction = factions[factionTags[i]];

                if (faction == undefined) continue;

                str += "\n\n**Faction:** " + faction["name"] + "\n**Tag:** " + factionTags[i] + "\n**Color:** " + faction["color"];
            }

            const voidEmbed = createArgoEmbed("Faction List", str, null, null);

            interaction.channel.send({embeds: [voidEmbed]});
            interaction.reply({content: '*Faction List Processed*', ephemeral: true});
        }else if (interaction.commandName == 'editfaction'){
            const name = await interaction.options.getString('name');
            const tag = await interaction.options.getString('tag');
            const color = await interaction.options.getString('color');
            const description = await interaction.options.getString('description');

            if (name){
                factions[tag]["name"] = name;
            }

            if (color){
                factions[tag]["color"] = color;
            }

            if (description){
                factions[tag]["description"] = description;
            }

            interaction.reply({content: '*Faction Edited*', ephemeral: true});
            writeConfig();
            updateRoles(interaction);
        }else if (interaction.commandName == 'manualroleupdate'){ 
            let b  = false;
            let member = await interaction.guild.members.fetch(interaction.user.id);
            
            const list = await interaction.client.guilds.cache.get(process.env.GUILD_ID).members.fetch();

            for (u of list){
                for (let i = 0; i < factionTags.length; i++) {
                    if (factions[factionTags[i]]["owner"] == undefined) continue;
                    if (factions[factionTags[i]]["owner"] == "Null") continue;

                    let user = u[1].user;
    
                    console.log(factions[factionTags[i]]["owner"] + " | " + user.id);
                    if (factions[factionTags[i]]["owner"] == user.id) {
                        b = true;
                        console.log("ADD PLAYER ROLE");
                        
                        
                        await interaction.guild.members.fetch(user.id).then((member) => {
                            if (member.roles.cache.has(playerRole) && !member.roles.cache.has(spectatorRole)) return;
    
                            member.roles.add(playerRole);
                            member.roles.remove(spectatorRole);
                            
                            console.log(member.user.username);
                        });

                        
                    }
    
                    if (!b){
                        console.log("REMOVE PLAYER ROLE");

                        

                        await interaction.guild.members.fetch(user.id).then((member) => {
                            if (member.roles.cache.has(spectatorRole) && !member.roles.cache.has(playerRole)) return;
    
                            member.roles.add(spectatorRole);
                            member.roles.remove(playerRole);
                            
                        });

                        
                    }
                }
            }

            
        }else if(interaction.commandName == 'debug'){
            if (interaction.member.permissions.has(PermissionsBitField.ManageRoles)){
                let b  = false;
                let member = await interaction.guild.members.fetch(interaction.user.Id);
                console.log(member.roles);
                for (let i = 0; i < factionTags.length; i++) {
                    if (factions[factionTags[i]]["owner"] == undefined) continue;

                    console.log(factions[factionTags[i]]["owner"] + " | " + context.user.Id);
                    if (factions[factionTags[i]]["owner"] == context.user.Id) {
                        b = true;
                        await interaction.guild.members.fetch(interaction.user.Id).then((member) => {
                            if (member.roles.has(playerRole)) return;

                            member.roles.add(playerRole);
                            member.roles.remove(spectatorRole);
                        });
                    }

                    if (!b){
                        await interaction.guild.members.fetch(interaction.user.Id).then((member) => {
                            if (member.roles.has(spectatorRole)) return;

                            member.roles.add(spectatorRole);
                            member.roles.remove(playerRole);
                        });
                    }
                }
                
            }else{
                interaction.reply({content: '*You do not have permission to use this command*', ephemeral: true});
            }
        }
            */

    } catch (error) {
        console.log(error);
    }
});

c.login(token);
})